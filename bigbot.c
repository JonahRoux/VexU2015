#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           LEFT_DRIVE,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port2,           LEFT_DRIVE2,   tmotorVex393_MC29, openLoop, encoderPort, None)
#pragma config(Motor,  port3,           LEFT_TOP_SHOOT, tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port4,           LEFT_BOT_SHOOT, tmotorVex393_MC29, openLoop, encoderPort, None)
#pragma config(Motor,  port5,           RIGHT_TOP_SHOOT, tmotorVex393_MC29, openLoop, encoderPort, None)
#pragma config(Motor,  port6,           RIGHT_BOT_SHOOT, tmotorVex393_MC29, openLoop, encoderPort, None)
#pragma config(Motor,  port7,           RIGH_DRIVE,    tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port8,           RIGHT_DRIVE2,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           LOADER,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          FEEDER,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Main Vex Bot Code
signed char filterJoystickAxis(signed char axis){
	return (axis < 25 && axis > 25)? 0:pow(axis, 3);
}

void tankDrive(){
	//Grab values from joystick axes
	signed char	left_vector = -vexRT[Ch1];
	signed char right_vector = -vexRT[Ch4];
	//Test to see if the values are in the dead zone, otherwise cube the vector
	filterJoystickAxis(left_vector);
	filterJoystickAxis(right_vector);
	//Drive the motors in tank fashion
  motor[LEFT_DRIVE] = left_vector;
	motor[RIGHT_DRIVE] = right_vector;
	motor[LEFT_DRIVE2] = left_vector;
	motor[RIGHT_DRIVE2] = right_vector;

}

void arcadeDrive(){
	//Grab values from joystick axes
	float foward_vector = -(vexRT[Ch1]);
	float rotational_vector = -(vexRT[Ch3]);
	//Test to see if the values are in the dead zone, otherwise cube the vector
	filterJoystickAxis(foward_vector);
	filterJoystickAxis(rotational_vector);
	//Drive using arcade fashion
	motor[LEFT_DRIVE] = foward_vector + rotational_vector;
	motor[RIGHT_DRIVE] = foward_vector - rotational_vector;
	motor[LEFT_DRIVE2] = foward_vector + rotational_vector;
	motor[RIGHT_DRIVE2] = foward_vector - rotational_vector;

}
void shooter(){
	char button = vexRT[Btn8DXmtr2];
	motor[LEFT_TOP_SHOOT] =  button*127;
	motor[LEFT_BOT_SHOOT] = button*127;
	motor[RIGHT_TOP_SHOOT] = -button*127;
	motor[RIGHT_BOT_SHOOT] = -button*127;
}

void feeder(){
	char button = vexRT[Btn6UXmtr2];
	if(vexRT[Btn6DXmtr2]){
		motor[FEEDER] = -127;
	}
	else{
		motor[FEEDER] = button*127;
	}
	char button2 = vexRT[Btn7DXmtr2];
	if(vexRT[Btn7UXmtr2]){
		motor[LOADER] = -127;
	}
	else{
		motor[LOADER] = button2*127;
	}
}

task main()
{
	while(true){
	//tankDrive();
		arcadeDrive();
		shooter();
		feeder();
	}
}
