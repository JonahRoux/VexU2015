#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           RIGHT_BOT_SHOOT, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           RIGHT_DRIVE,   tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           LEFT_DRIVE,    tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port4,           RIGHT_TOP_SHOOT, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port5,           INTAKE,        tmotorVex393_MC29, openLoop, encoderPort, None)
#pragma config(Motor,  port6,           FEEDER,        tmotorVex393_MC29, openLoop, encoderPort, None)
#pragma config(Motor,  port7,           LEFT_TOP_SHOOT, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port8,           LEFT_BOT_SHOOT, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          LOADER,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Main Vex Bot Code
signed char filterJoystickAxis(signed char axis){
	return (axis < 25 && axis > 25)? 0:pow(axis, 3);
}

void tankDrive(){
	//Grab values from joystick axes
	signed char	left_vector = vexRT[Ch3];
	signed char right_vector = vexRT[Ch2];
	//Test to see if the values are in the dead zone, otherwise cube the vector
	filterJoystickAxis(left_vector);
	filterJoystickAxis(right_vector);
	//Drive the motors in tank fashion
  motor[LEFT_DRIVE] = left_vector;
	motor[RIGHT_DRIVE] = -right_vector;
}

void arcadeDrive(){
	//Grab values from joystick axes
	float foward_vector = vexRT[Ch1];
	float rotational_vector = vexRT[Ch3];
	//Test to see if the values are in the dead zone, otherwise cube the vector
	filterJoystickAxis(foward_vector);
	filterJoystickAxis(rotational_vector);
	//Drive using arcade fashion
	motor[LEFT_DRIVE] = foward_vector + rotational_vector;
	motor[RIGHT_DRIVE] = foward_vector - rotational_vector;
}
void shooter(){
	char button = vexRT[Btn8DXmtr2];
	motor[LEFT_TOP_SHOOT] =  button*127;
	motor[LEFT_BOT_SHOOT] = button*127;
	motor[RIGHT_TOP_SHOOT] = -button*127;
	motor[RIGHT_BOT_SHOOT] = -button*127;

	char button2 = vexRT[Btn7DXmtr2];
	motor[LOADER] = button2*127;
}

void feeder(){
	char button = vexRT[Btn6UXmtr2];
	if (vexRT[Btn5UXmtr2]){
		motor[FEEDER] = -127;
	}
	else{
		motor[FEEDER] = button*127;
	}
	char button2 = vexRT[Btn6U];
	motor[INTAKE] = button2*127;
}

int encoder;

task main()
{
	while(true){
		//tankDrive();
		arcadeDrive();
		shooter();
		feeder();
//		motor[LEFT_DRIVE] =  127;
		encoder = nMotorEncoderRaw[LEFT_DRIVE];
	}
}
